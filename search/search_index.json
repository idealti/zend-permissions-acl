{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-permissions-acl Repository abandoned 2019-12-31 This repository has moved to laminas/laminas-permissions-acl . Provides a lightweight and flexible access control list (ACL) implementation for privileges management. File issues at https://github.com/zendframework/zend-permissions-acl/issues Documentation is at https://docs.zendframework.com/zend-permissions-acl/","title":"Home"},{"location":"#zend-permissions-acl","text":"","title":"zend-permissions-acl"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to laminas/laminas-permissions-acl . Provides a lightweight and flexible access control list (ACL) implementation for privileges management. File issues at https://github.com/zendframework/zend-permissions-acl/issues Documentation is at https://docs.zendframework.com/zend-permissions-acl/","title":"Repository abandoned 2019-12-31"},{"location":"advanced/","text":"Advanced Usage Storing ACL Data for Persistence zend-permissions-acl was designed in such a way that it does not require any particular backend technology such as a database or cache server for storage of the ACL data. Its complete PHP implementation enables customized administration tools to be built upon Zend\\Permissions\\Acl\\Acl with relative ease and flexibility. Many situations require some form of interactive maintenance of the ACL, and Zend\\Permissions\\Acl\\Acl provides methods for setting up, and querying against, the access controls of an application. Storage of ACL data is therefore left as a task for the developer, since use cases are expected to vary widely for various situations. Because Zend\\Permissions\\Acl\\Acl is serializable, ACL objects may be serialized with PHP's serialize() function , and the results may be stored anywhere the developer should desire, such as a file, database, or caching mechanism. Writing Conditional ACL Rules with Assertions Sometimes a rule for allowing or denying a role access to a resource should not be absolute, but dependent upon various criteria. For example, suppose that certain access should be allowed, but only between the hours of 8:00am and 5:00pm. Another example would be denying access because a request comes from an IP address that has been flagged as a source of abuse. Zend\\Permissions\\Acl\\Acl has built-in support for implementing rules based on whatever conditions the developer needs. Zend\\Permissions\\Acl\\Acl provides support for conditional rules with Zend\\Permissions\\Acl\\Assertion\\AssertionInterface . In order to use the rule assertion interface, a developer writes a class that implements the assert() method of the interface: use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Assertion\\AssertionInterface; use Zend\\Permissions\\Acl\\Role\\RoleInterface; use Zend\\Permissions\\Acl\\Resource\\ResourceInterface; class CleanIPAssertion implements AssertionInterface { public function assert( Acl $acl, RoleInterface $role = null, ResourceInterface $resource = null, $privilege = null ) { return $this->_isCleanIP($_SERVER['REMOTE_ADDR']); } protected function _isCleanIP($ip) { // ... } } Once an assertion class is available, the developer must supply an instance of the assertion class when assigning conditional rules. A rule that is created with an assertion only applies when the assertion method returns TRUE . use Zend\\Permissions\\Acl\\Acl; $acl = new Acl(); $acl->allow(null, null, null, new CleanIPAssertion()); The above code creates a conditional allow rule that allows access to all privileges on everything by everyone, except when the requesting IP is \"blacklisted\". If a request comes in from an IP that is not considered \"clean\", then the allow rule does not apply. Since the rule applies to all roles, all resources, and all privileges, an \"unclean\" IP would result in a denial of access. This is a special case, however, and it should be understood that in all other cases (i.e., where a specific role, resource, or privilege is specified for the rule), a failed assertion results in the rule not applying, and other rules would be used to determine whether access is allowed or denied. The assert() method of an assertion object is passed the ACL, role, resource, and privilege to which the authorization query (i.e., isAllowed() ) applies, in order to provide a context for the assertion class to determine its conditions where needed.","title":"Advanced Usage"},{"location":"advanced/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced/#storing-acl-data-for-persistence","text":"zend-permissions-acl was designed in such a way that it does not require any particular backend technology such as a database or cache server for storage of the ACL data. Its complete PHP implementation enables customized administration tools to be built upon Zend\\Permissions\\Acl\\Acl with relative ease and flexibility. Many situations require some form of interactive maintenance of the ACL, and Zend\\Permissions\\Acl\\Acl provides methods for setting up, and querying against, the access controls of an application. Storage of ACL data is therefore left as a task for the developer, since use cases are expected to vary widely for various situations. Because Zend\\Permissions\\Acl\\Acl is serializable, ACL objects may be serialized with PHP's serialize() function , and the results may be stored anywhere the developer should desire, such as a file, database, or caching mechanism.","title":"Storing ACL Data for Persistence"},{"location":"advanced/#writing-conditional-acl-rules-with-assertions","text":"Sometimes a rule for allowing or denying a role access to a resource should not be absolute, but dependent upon various criteria. For example, suppose that certain access should be allowed, but only between the hours of 8:00am and 5:00pm. Another example would be denying access because a request comes from an IP address that has been flagged as a source of abuse. Zend\\Permissions\\Acl\\Acl has built-in support for implementing rules based on whatever conditions the developer needs. Zend\\Permissions\\Acl\\Acl provides support for conditional rules with Zend\\Permissions\\Acl\\Assertion\\AssertionInterface . In order to use the rule assertion interface, a developer writes a class that implements the assert() method of the interface: use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Assertion\\AssertionInterface; use Zend\\Permissions\\Acl\\Role\\RoleInterface; use Zend\\Permissions\\Acl\\Resource\\ResourceInterface; class CleanIPAssertion implements AssertionInterface { public function assert( Acl $acl, RoleInterface $role = null, ResourceInterface $resource = null, $privilege = null ) { return $this->_isCleanIP($_SERVER['REMOTE_ADDR']); } protected function _isCleanIP($ip) { // ... } } Once an assertion class is available, the developer must supply an instance of the assertion class when assigning conditional rules. A rule that is created with an assertion only applies when the assertion method returns TRUE . use Zend\\Permissions\\Acl\\Acl; $acl = new Acl(); $acl->allow(null, null, null, new CleanIPAssertion()); The above code creates a conditional allow rule that allows access to all privileges on everything by everyone, except when the requesting IP is \"blacklisted\". If a request comes in from an IP that is not considered \"clean\", then the allow rule does not apply. Since the rule applies to all roles, all resources, and all privileges, an \"unclean\" IP would result in a denial of access. This is a special case, however, and it should be understood that in all other cases (i.e., where a specific role, resource, or privilege is specified for the rule), a failed assertion results in the rule not applying, and other rules would be used to determine whether access is allowed or denied. The assert() method of an assertion object is passed the ACL, role, resource, and privilege to which the authorization query (i.e., isAllowed() ) applies, in order to provide a context for the assertion class to determine its conditions where needed.","title":"Writing Conditional ACL Rules with Assertions"},{"location":"expression/","text":"Expression Assertions Available since version 2.7.0 Many custom assertions are doing basic comparisons: Equality of a role property to a value or property of the resource. Other comparisons ( > , < , in_array , etc.) of a role property to a value or values (potentially a property of the resource). Regular expressions. While these can be easily accommodated by the CallbackAssertion , such assertions have one notable problem: they cannot be easily serialized. To facilitate such assertions, we now provide Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion . This class provides two static factory methods for creating an instance, each expecting the following: The left operand An operator The right operand When the assertion is executed, it uses the operator to determine how to compare the two operands, and thus answer the assertion. Operands The operands can be any PHP value. Additionally, they can be an associative array containing the key ExpressionAssertion::OPERAND_CONTEXT_PROPERTY ( __context ), with a string value. That value can be one of the following: A string matching the values \"acl\", \"privilege\", \"role\", or \"resource\", with the latter two being most common. When one of these is provided, the corresponding argument to the assert() method will be used. A dot-separated string with the first segment being one of the above values, and the second being a property or field of that object. The ExpressionAssertion will test for: a method matching get<field>() a method matching is<field>() a public property named <field> in that specific order. In the first two cases, <field> will be normalized to WordCase when creating the method name to test. Operators ExpressionAssertion supports the following operators: const OPERATOR_EQ = '='; const OPERATOR_NEQ = '!='; const OPERATOR_LT = '<'; const OPERATOR_LTE = '<='; const OPERATOR_GT = '>'; const OPERATOR_GTE = '>='; const OPERATOR_IN = 'in'; const OPERATOR_NIN = '!in'; const OPERATOR_REGEX = 'regex'; const OPERATOR_NREGEX = '!regex'; const OPERATOR_SAME = '==='; const OPERATOR_NSAME = '!=='; In most cases, these will operate using the operators as listed above, with the following exceptions: OPERATOR_EQ will use == as the comparison operator; OPERATOR_NEQ will likewise use != . OPERATOR_IN and OPERATOR_NIN use in_array() (with the latter negating the result), both doing strict comparisons. The right hand operand is expected to be the array in which to look for results, and the left hand operand is expected to be the needle to look for. OPERATOR_REGEX and OPERATOR_NREGEX will perform a preg_match() operation, using the right hand operand as the regular expression, and the left hand operand as the value to compare. Constructors The constructor of ExpressionAssertion is private. Instead, you will use one of two static methods in order to create instances: fromProperties($left, $operator, $right) fromArray(array $expression) (expects keys for \"left\", \"operator\", and \"right\") When creating expressions manually, the first is generally the best choice. When storing expressions in configuration or a database, the latter is useful, as you can pass a row of data at a time to the method to get expression instances. Examples First, we'll define both a role and a resource: namespace Blog\\Entity; use Zend\\Permissions\\Acl\\Resource\\ResourceInterface; use Zend\\Permissions\\Acl\\Role\\RoleInterface; class BlogPost implements ResourceInterface { public $title; public $shortDescription; public $content; public $author; public function __construct(array $data = []) { foreach ($data as $property => $value) { $this->$property = $value; } } public function getResourceId() { return 'blogPost'; } public function getShortDescription() { return $this->shortDescription; } public function getAuthorName() { return $this->author ? $this->author->username : ''; } } class User implements RoleInterface { public $username; public $role = 'guest'; public $age; public function __construct(array $data = []) { foreach ($data as $property => $value) { $this->$property = $value; } } public function getRoleId() { return $this->role; } public function isAdult() { return $this->age >= 18; } } Next, let's define some assertions. use Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion; // Username of role must be \"test\": // Will access $username property on the role instance. $isTestUser = ExpressionAssertion::fromProperties( [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.username'], '===', 'test' ); // Role must be at least 18 years old: // Will execute `isAdult()` on the role instance. $isOfLegalAge = ExpressionAssertion::fromProperties( [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.adult'], '===', true ); // Must have edited text: // Will do a regex comparison on the shortDescription of the blog post // to ensure we do not have filler text. $isEditedDescription = ExpressionAssertion::fromArray([ 'left' => [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'resource.shortDescription'], 'operator' => '!regex', 'right' => '/lorem ipsum/i', ]);","title":"Expression Assertions"},{"location":"expression/#expression-assertions","text":"Available since version 2.7.0 Many custom assertions are doing basic comparisons: Equality of a role property to a value or property of the resource. Other comparisons ( > , < , in_array , etc.) of a role property to a value or values (potentially a property of the resource). Regular expressions. While these can be easily accommodated by the CallbackAssertion , such assertions have one notable problem: they cannot be easily serialized. To facilitate such assertions, we now provide Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion . This class provides two static factory methods for creating an instance, each expecting the following: The left operand An operator The right operand When the assertion is executed, it uses the operator to determine how to compare the two operands, and thus answer the assertion.","title":"Expression Assertions"},{"location":"expression/#operands","text":"The operands can be any PHP value. Additionally, they can be an associative array containing the key ExpressionAssertion::OPERAND_CONTEXT_PROPERTY ( __context ), with a string value. That value can be one of the following: A string matching the values \"acl\", \"privilege\", \"role\", or \"resource\", with the latter two being most common. When one of these is provided, the corresponding argument to the assert() method will be used. A dot-separated string with the first segment being one of the above values, and the second being a property or field of that object. The ExpressionAssertion will test for: a method matching get<field>() a method matching is<field>() a public property named <field> in that specific order. In the first two cases, <field> will be normalized to WordCase when creating the method name to test.","title":"Operands"},{"location":"expression/#operators","text":"ExpressionAssertion supports the following operators: const OPERATOR_EQ = '='; const OPERATOR_NEQ = '!='; const OPERATOR_LT = '<'; const OPERATOR_LTE = '<='; const OPERATOR_GT = '>'; const OPERATOR_GTE = '>='; const OPERATOR_IN = 'in'; const OPERATOR_NIN = '!in'; const OPERATOR_REGEX = 'regex'; const OPERATOR_NREGEX = '!regex'; const OPERATOR_SAME = '==='; const OPERATOR_NSAME = '!=='; In most cases, these will operate using the operators as listed above, with the following exceptions: OPERATOR_EQ will use == as the comparison operator; OPERATOR_NEQ will likewise use != . OPERATOR_IN and OPERATOR_NIN use in_array() (with the latter negating the result), both doing strict comparisons. The right hand operand is expected to be the array in which to look for results, and the left hand operand is expected to be the needle to look for. OPERATOR_REGEX and OPERATOR_NREGEX will perform a preg_match() operation, using the right hand operand as the regular expression, and the left hand operand as the value to compare.","title":"Operators"},{"location":"expression/#constructors","text":"The constructor of ExpressionAssertion is private. Instead, you will use one of two static methods in order to create instances: fromProperties($left, $operator, $right) fromArray(array $expression) (expects keys for \"left\", \"operator\", and \"right\") When creating expressions manually, the first is generally the best choice. When storing expressions in configuration or a database, the latter is useful, as you can pass a row of data at a time to the method to get expression instances.","title":"Constructors"},{"location":"expression/#examples","text":"First, we'll define both a role and a resource: namespace Blog\\Entity; use Zend\\Permissions\\Acl\\Resource\\ResourceInterface; use Zend\\Permissions\\Acl\\Role\\RoleInterface; class BlogPost implements ResourceInterface { public $title; public $shortDescription; public $content; public $author; public function __construct(array $data = []) { foreach ($data as $property => $value) { $this->$property = $value; } } public function getResourceId() { return 'blogPost'; } public function getShortDescription() { return $this->shortDescription; } public function getAuthorName() { return $this->author ? $this->author->username : ''; } } class User implements RoleInterface { public $username; public $role = 'guest'; public $age; public function __construct(array $data = []) { foreach ($data as $property => $value) { $this->$property = $value; } } public function getRoleId() { return $this->role; } public function isAdult() { return $this->age >= 18; } } Next, let's define some assertions. use Zend\\Permissions\\Acl\\Assertion\\ExpressionAssertion; // Username of role must be \"test\": // Will access $username property on the role instance. $isTestUser = ExpressionAssertion::fromProperties( [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.username'], '===', 'test' ); // Role must be at least 18 years old: // Will execute `isAdult()` on the role instance. $isOfLegalAge = ExpressionAssertion::fromProperties( [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'role.adult'], '===', true ); // Must have edited text: // Will do a regex comparison on the shortDescription of the blog post // to ensure we do not have filler text. $isEditedDescription = ExpressionAssertion::fromArray([ 'left' => [ExpressionAssertion::OPERAND_CONTEXT_PROPERTY => 'resource.shortDescription'], 'operator' => '!regex', 'right' => '/lorem ipsum/i', ]);","title":"Examples"},{"location":"ownership/","text":"Ownership Assertions Available since version 2.7.0 When setting up permissions for an application, site owners common will want to allow roles to manipulate resources owned by the user with that role. For example, a blog author should have permission to write new posts, and also to modify his or her own posts, but not posts of other authors. To accomodate this use case, we provide two interfaces: Zend\\Acl\\ProprietaryInterface is applicable to resources and roles . It provides information about the owner of an object. Objects implementing this interface are used in conjunction with the OwnershipAssertion . Zend\\Acl\\Assertion\\OwnershipAssertion ensures that a resource is owned by a specific role by comparing it to owners provided by ProprietaryInterface implementations. Example Consider the following entities: namespace MyApp\\Entity; use Zend\\Permissions\\Acl\\ProprietaryInterface; use Zend\\Permissions\\Acl\\Resource\\ResourceInterface; use Zend\\Permissions\\Acl\\Role\\RoleInterface; class User implements RoleInterface, ProprietaryInterface { protected $id; protected $role = 'guest'; public function __construct($id, $role) { $this->id = $id; $this->role = $role; } public function getRoleId() { return $this->role; } public function getOwnerId() { return $this->id; } } class BlogPost implements ResourceInterface, ProprietaryInterface { public $author = null; public function getResourceId() { return 'blogPost'; } public function getOwnerId() { if ($this->author === null) { return null; } return $this->author->getOwnerId(); } } The User marks itself as an owner by implementing ProprietaryInterface ; its getOwnerId() method will return the user identifier provided during instantiation. A BlogPost marks itself as a resource and an owner by also implementing ProprietaryInterface ; in its case, it returns the author identifier, if present, but null otherwise. Now let's wire these up into an ACL: namespace MyApp; use MyApp\\Entity; use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Assertion\\OwnershipAssertion; $acl = new Acl(); $acl->addRole('guest'); $acl->addRole('member', 'guest'); $acl->addRole('author', 'member'); $acl->addRole('admin'); $acl->addResource('blogPost'); $acl->addResource('comment'); $acl->allow('guest', 'blogPost', 'view'); $acl->allow('guest', 'comment', array('view', 'submit')); $acl->allow('author', 'blogPost', 'write'); $acl->allow('author', 'blogPost', 'edit', new OwnershipAssertion()); $acl->allow('admin'); $author1 = new User(1, 'author'); $author2 = new User(2, 'author'); $blogPost = new BlogPost(); $blogPost->author = $author1; The takeaways from the above should be: An author can write blog posts, and edit posts it owns. $author1 and $author2 are both authors. $author1 is the author of $blogPost . Knowing these facts, we can expect the following assertion results: $acl->isAllowed($author1, 'blogPost', 'write'); // true $acl->isAllowed($author1, $blogPost, 'edit'); // true $acl->isAllowed($author2, 'blogPost', 'write'); // true $acl->isAllowed($author2, $blogPost, 'edit'); // false","title":"Ownership Assertions"},{"location":"ownership/#ownership-assertions","text":"Available since version 2.7.0 When setting up permissions for an application, site owners common will want to allow roles to manipulate resources owned by the user with that role. For example, a blog author should have permission to write new posts, and also to modify his or her own posts, but not posts of other authors. To accomodate this use case, we provide two interfaces: Zend\\Acl\\ProprietaryInterface is applicable to resources and roles . It provides information about the owner of an object. Objects implementing this interface are used in conjunction with the OwnershipAssertion . Zend\\Acl\\Assertion\\OwnershipAssertion ensures that a resource is owned by a specific role by comparing it to owners provided by ProprietaryInterface implementations.","title":"Ownership Assertions"},{"location":"refining/","text":"Refining Access Controls Precise Access Controls The basic ACL as defined in the previous section shows how various privileges may be allowed upon the entire ACL (all resources). In practice, however, access controls tend to have exceptions and varying degrees of complexity. Zend\\Permissions\\Acl\\Acl allows to you accomplish these refinements in a straightforward and flexible manner. For the example CMS, it has been determined that whilst the 'staff' group covers the needs of the vast majority of users, there is a need for a new 'marketing' group that requires access to the newsletter and latest news in the CMS. The group is fairly self-sufficient and will have the ability to publish and archive both newsletters and the latest news. In addition, it has also been requested that the 'staff' group be allowed to view news stories but not to revise the latest news. Finally, it should be impossible for anyone (administrators included) to archive any 'announcement' news stories since they only have a lifespan of 1-2 days. First we revise the role registry to reflect these changes. We have determined that the 'marketing' group has the same basic permissions as 'staff', so we define 'marketing' in such a way that it inherits permissions from 'staff': // The new marketing group inherits permissions from staff use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; use Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource; $acl = new Acl(); $acl->addRole(new Role('marketing'), 'staff'); Next, note that the above access controls refer to specific resources (e.g., \"newsletter\", \"latest news\", \"announcement news\"). Now we add these resources: // Create Resources for the rules // newsletter $acl->addResource(new Resource('newsletter')); // news $acl->addResource(new Resource('news')); // latest news $acl->addResource(new Resource('latest'), 'news'); // announcement news $acl->addResource(new Resource('announcement'), 'news'); Then it is simply a matter of defining these more specific rules on the target areas of the ACL: // Marketing must be able to publish and archive newsletters and the // latest news $acl->allow( 'marketing', ['newsletter', 'latest'], ['publish', 'archive'] ); // Staff (and marketing, by inheritance), are denied permission to // revise the latest news $acl->deny('staff', 'latest', 'revise'); // Everyone (including administrators) are denied permission to // archive news announcements $acl->deny(null, 'announcement', 'archive'); We can now query the ACL with respect to the latest changes: echo $acl->isAllowed('staff', 'newsletter', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'newsletter', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('staff', 'latest', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'latest', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'archive') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'revise') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('editor', 'announcement', 'archive') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('administrator', 'announcement', 'archive') ? 'allowed' : 'denied'; // denied Removing Access Controls To remove one or more access rules from the ACL, simply use the available removeAllow() or removeDeny() methods. As with allow() and deny() , you may provide a NULL value to indicate application to all roles, resources, and/or privileges: // Remove the denial of revising latest news to staff (and marketing, // by inheritance) $acl->removeDeny('staff', 'latest', 'revise'); echo $acl->isAllowed('marketing', 'latest', 'revise') ? 'allowed' : 'denied'; // allowed // Remove the allowance of publishing and archiving newsletters to // marketing $acl->removeAllow( 'marketing', 'newsletter', ['publish', 'archive'] ); echo $acl->isAllowed('marketing', 'newsletter', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'newsletter', 'archive') ? 'allowed' : 'denied'; // denied Privileges may be modified incrementally as indicated above, but a NULL value for the privileges overrides such incremental changes: // Allow marketing all permissions upon the latest news $acl->allow('marketing', 'latest'); echo $acl->isAllowed('marketing', 'latest', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'archive') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'anything') ? 'allowed' : 'denied'; // allowed","title":"Refining Access Controls"},{"location":"refining/#refining-access-controls","text":"","title":"Refining Access Controls"},{"location":"refining/#precise-access-controls","text":"The basic ACL as defined in the previous section shows how various privileges may be allowed upon the entire ACL (all resources). In practice, however, access controls tend to have exceptions and varying degrees of complexity. Zend\\Permissions\\Acl\\Acl allows to you accomplish these refinements in a straightforward and flexible manner. For the example CMS, it has been determined that whilst the 'staff' group covers the needs of the vast majority of users, there is a need for a new 'marketing' group that requires access to the newsletter and latest news in the CMS. The group is fairly self-sufficient and will have the ability to publish and archive both newsletters and the latest news. In addition, it has also been requested that the 'staff' group be allowed to view news stories but not to revise the latest news. Finally, it should be impossible for anyone (administrators included) to archive any 'announcement' news stories since they only have a lifespan of 1-2 days. First we revise the role registry to reflect these changes. We have determined that the 'marketing' group has the same basic permissions as 'staff', so we define 'marketing' in such a way that it inherits permissions from 'staff': // The new marketing group inherits permissions from staff use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; use Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource; $acl = new Acl(); $acl->addRole(new Role('marketing'), 'staff'); Next, note that the above access controls refer to specific resources (e.g., \"newsletter\", \"latest news\", \"announcement news\"). Now we add these resources: // Create Resources for the rules // newsletter $acl->addResource(new Resource('newsletter')); // news $acl->addResource(new Resource('news')); // latest news $acl->addResource(new Resource('latest'), 'news'); // announcement news $acl->addResource(new Resource('announcement'), 'news'); Then it is simply a matter of defining these more specific rules on the target areas of the ACL: // Marketing must be able to publish and archive newsletters and the // latest news $acl->allow( 'marketing', ['newsletter', 'latest'], ['publish', 'archive'] ); // Staff (and marketing, by inheritance), are denied permission to // revise the latest news $acl->deny('staff', 'latest', 'revise'); // Everyone (including administrators) are denied permission to // archive news announcements $acl->deny(null, 'announcement', 'archive'); We can now query the ACL with respect to the latest changes: echo $acl->isAllowed('staff', 'newsletter', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'newsletter', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('staff', 'latest', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'latest', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'archive') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'revise') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('editor', 'announcement', 'archive') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('administrator', 'announcement', 'archive') ? 'allowed' : 'denied'; // denied","title":"Precise Access Controls"},{"location":"refining/#removing-access-controls","text":"To remove one or more access rules from the ACL, simply use the available removeAllow() or removeDeny() methods. As with allow() and deny() , you may provide a NULL value to indicate application to all roles, resources, and/or privileges: // Remove the denial of revising latest news to staff (and marketing, // by inheritance) $acl->removeDeny('staff', 'latest', 'revise'); echo $acl->isAllowed('marketing', 'latest', 'revise') ? 'allowed' : 'denied'; // allowed // Remove the allowance of publishing and archiving newsletters to // marketing $acl->removeAllow( 'marketing', 'newsletter', ['publish', 'archive'] ); echo $acl->isAllowed('marketing', 'newsletter', 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('marketing', 'newsletter', 'archive') ? 'allowed' : 'denied'; // denied Privileges may be modified incrementally as indicated above, but a NULL value for the privileges overrides such incremental changes: // Allow marketing all permissions upon the latest news $acl->allow('marketing', 'latest'); echo $acl->isAllowed('marketing', 'latest', 'publish') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'archive') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('marketing', 'latest', 'anything') ? 'allowed' : 'denied'; // allowed","title":"Removing Access Controls"},{"location":"usage/","text":"Theory and Usage zend-permissions-acl provides a lightweight and flexible access control list (ACL) implementation for privileges management. In general, an application may utilize such ACLs to control access to certain protected objects by other requesting objects. For the purposes of this documentation: a resource is an object to which access is controlled. a role is an object that may request access to a resource. Put simply, roles request access to resources . For example, if a parking attendant requests access to a car, then the parking attendant is the requesting role, and the car is the resource, since access to the car may not be granted to everyone. Through the specification and use of an AC*, an application may control how roles are granted access to resources. Resources Creating a resource using Zend\\Permissions\\Acl\\Acl is very simple. A resource interface Zend\\Permissions\\Acl\\Resource\\ResourceInterface is provided to facilitate creating resources in an application. A class need only implement this interface, which consists of a single method, getResourceId() , for Zend\\Permissions\\Acl\\Acl to recognize the object as a resource. Additionally, Zend\\Permissions\\Acl\\Resource\\GenericResource is provided as a basic resource implementation for developers to extend as needed. Zend\\Permissions\\Acl\\Acl provides a tree structure to which multiple resources can be added. Since resources are stored in such a tree structure, they can be organized from the general (toward the tree root) to the specific (toward the tree leaves). Queries on a specific resource will automatically search the resource's hierarchy for rules assigned to ancestor resources, allowing for simple inheritance of rules. For example, if a default rule is to be applied to each building in a city, one would simply assign the rule to the city, instead of assigning the same rule to each building. Some buildings may require exceptions to such a rule, however, and this can be achieved in Zend\\Permissions\\Acl\\Acl by assigning such exception rules to each building that requires such an exception. A resource may inherit from only one parent resource, though this parent resource can have its own parent resource, etc. Zend\\Permissions\\Acl\\Acl also supports privileges on resources (e.g., \"create\", \"read\", \"update\", \"delete\"), so the developer can assign rules that affect all privileges or specific privileges on one or more resources. Roles As with resources, creating a role is also very simple. All roles must implement Zend\\Permissions\\Acl\\Role\\RoleInterface . This interface consists of a single method, getRoleId() , Additionally, Zend\\Permissions\\Acl\\Role\\GenericRole is provided by the Zend\\Permissions\\Acl component as a basic role implementation for developers to extend as needed. In Zend\\Permissions\\Acl\\Acl , a role may inherit from one or more roles. This is to support inheritance of rules among roles. For example, a user role, such as \"sally\", may belong to one or more parent roles, such as \"editor\" and \"administrator\". The developer can assign rules to \"editor\" and \"administrator\" separately, and \"sally\" would inherit such rules from both, without having to assign rules directly to \"sally\". Though the ability to inherit from multiple roles is very useful, multiple inheritance also introduces some degree of complexity. The following example illustrates the ambiguity condition and how Zend\\Permissions\\Acl\\Acl solves it. Multiple Inheritance among Roles The following code defines three base roles - \"guest\", \"member\", and \"admin\" - from which other roles may inherit. Then, a role identified by \"someUser\" is established and inherits from the three other roles. The order in which these roles appear in the $parents array is important. When necessary, Zend\\Permissions\\Acl\\Acl searches for access rules defined not only for the queried role (herein, \"someUser\"), but also upon the roles from which the queried role inherits (herein, \"guest\", \"member\", and \"admin\"): use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; use Zend\\Permissions\\Acl\\Resource\\GenericResource as Resource; $acl = new Acl(); $acl->addRole(new Role('guest')) ->addRole(new Role('member')) ->addRole(new Role('admin')); $parents = array('guest', 'member', 'admin'); $acl->addRole(new Role('someUser'), $parents); $acl->addResource(new Resource('someResource')); $acl->deny('guest', 'someResource'); $acl->allow('member', 'someResource'); echo $acl->isAllowed('someUser', 'someResource') ? 'allowed' : 'denied'; Since there is no rule specifically defined for the \"someUser\" role and \"someResource\", Zend\\Permissions\\Acl\\Acl must search for rules that may be defined for roles that \"someUser\" inherits. First, the \"admin\" role is visited, and there is no access rule defined for it. Next, the \"member\" role is visited, and Zend\\Permissions\\Acl\\Acl finds that there is a rule specifying that \"member\" is allowed access to \"someResource\". If Zend\\Permissions\\Acl\\Acl were to continue examining the rules defined for other parent roles, however, it would find that \"guest\" is denied access to \"someResource\". This fact introduces an ambiguity because now \"someUser\" is both denied and allowed access to \"someResource\", by reason of having inherited conflicting rules from different parent roles. Zend\\Permissions\\Acl\\Acl resolves this ambiguity by completing a query when it finds the first rule that is directly applicable to the query. In this case, since the \"member\" role is examined before the \"guest\" role, the example code would print \"allowed\". LIFO Order for Role Queries When specifying multiple parents for a role, keep in mind that the last parent listed is the first one searched for rules applicable to an authorization query. Creating the Access Control List An Access Control List (ACL) can represent any set of physical or virtual objects that you wish. For the purposes of demonstration, however, we will create a basic Content Management System (CMS) ACL that maintains several tiers of groups over a wide variety of areas. To create a new ACL object, we instantiate the ACL with no parameters: use Zend\\Permissions\\Acl\\Acl; $acl = new Acl(); Denied by default Until a developer specifies an \"allow\" rule, Zend\\Permissions\\Acl\\Acl denies access to every privilege upon every resource by every role. Registering Roles CMS systems will nearly always require a hierarchy of permissions to determine the authoring capabilities of its users. There may be a 'Guest' group to allow limited access for demonstrations, a 'Staff' group for the majority of CMS users who perform most of the day-to-day operations, an 'Editor' group for those responsible for publishing, reviewing, archiving and deleting content, and finally an 'Administrator' group whose tasks may include all of those of the other groups as well as maintenance of sensitive information, user management, back-end configuration data, backup and export. This set of permissions can be represented in a role registry, allowing each group to inherit privileges from 'parent' groups, as well as providing distinct privileges for their unique group only. The permissions may be expressed as follows: Name Unique Permissions Inherit Permissions From Guest View N/A Staff Edit, Submit, Revise Guest Editor Publish, Archive, Delete Staff Administrator (Granted all access) N/A For this example, Zend\\Permissions\\Acl\\Role\\GenericRole is used, but any object that implements Zend\\Permissions\\Acl\\Role\\RoleInterface is acceptable. These groups can be added to the role registry as follows: use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; $acl = new Acl(); // Add groups to the Role registry using Zend\\Permissions\\Acl\\Role\\GenericRole // Guest does not inherit access controls $roleGuest = new Role('guest'); $acl->addRole($roleGuest); // Staff inherits from guest $acl->addRole(new Role('staff'), $roleGuest); /* Alternatively, the above could be written: $acl->addRole(new Role('staff'), 'guest'); */ // Editor inherits from staff $acl->addRole(new Role('editor'), 'staff'); // Administrator does not inherit access controls $acl->addRole(new Role('administrator')); Defining Access Controls Now that the ACL contains the relevant roles, rules can be established that define how resources may be accessed by roles. You may have noticed that we have not defined any particular resources for this example, which is simplified to illustrate that the rules apply to all resources. Zend\\Permissions\\Acl\\Acl provides an implementation whereby rules need only be assigned from general to specific, minimizing the number of rules needed, because resources and roles inherit rules that are defined upon their ancestors. Specificity In general, Zend\\Permissions\\Acl\\Acl obeys a given rule if and only if a more specific rule does not apply. Consequently, we can define a reasonably complex set of rules with a minimum amount of code. To apply the base permissions as defined above: use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; $acl = new Acl(); $roleGuest = new Role('guest'); $acl->addRole($roleGuest); $acl->addRole(new Role('staff'), $roleGuest); $acl->addRole(new Role('editor'), 'staff'); $acl->addRole(new Role('administrator')); // Guest may only view content $acl->allow($roleGuest, null, 'view'); /* Alternatively, the above could be written: $acl->allow('guest', null, 'view'); */ // Staff inherits view privilege from guest, but also needs additional // privileges $acl->allow('staff', null, array('edit', 'submit', 'revise')); // Editor inherits view, edit, submit, and revise privileges from // staff, but also needs additional privileges $acl->allow('editor', null, array('publish', 'archive', 'delete')); // Administrator inherits nothing, but is allowed all privileges $acl->allow('administrator'); The NULL values in the above allow() calls are used to indicate that the allow rules apply to all resources. Querying an ACL We now have a flexible ACL that can be used to determine whether requesters have permission to perform functions throughout the web application. Performing queries is quite simple using the isAllowed() method: echo $acl->isAllowed('guest', null, 'view') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('staff', null, 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('staff', null, 'revise') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('editor', null, 'view') ? 'allowed' : 'denied'; // allowed because of inheritance from guest echo $acl->isAllowed('editor', null, 'update') ? 'allowed' : 'denied'; // denied because no allow rule for 'update' echo $acl->isAllowed('administrator', null, 'view') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges echo $acl->isAllowed('administrator') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges echo $acl->isAllowed('administrator', null, 'update') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges","title":"Theory and Usage"},{"location":"usage/#theory-and-usage","text":"zend-permissions-acl provides a lightweight and flexible access control list (ACL) implementation for privileges management. In general, an application may utilize such ACLs to control access to certain protected objects by other requesting objects. For the purposes of this documentation: a resource is an object to which access is controlled. a role is an object that may request access to a resource. Put simply, roles request access to resources . For example, if a parking attendant requests access to a car, then the parking attendant is the requesting role, and the car is the resource, since access to the car may not be granted to everyone. Through the specification and use of an AC*, an application may control how roles are granted access to resources.","title":"Theory and Usage"},{"location":"usage/#resources","text":"Creating a resource using Zend\\Permissions\\Acl\\Acl is very simple. A resource interface Zend\\Permissions\\Acl\\Resource\\ResourceInterface is provided to facilitate creating resources in an application. A class need only implement this interface, which consists of a single method, getResourceId() , for Zend\\Permissions\\Acl\\Acl to recognize the object as a resource. Additionally, Zend\\Permissions\\Acl\\Resource\\GenericResource is provided as a basic resource implementation for developers to extend as needed. Zend\\Permissions\\Acl\\Acl provides a tree structure to which multiple resources can be added. Since resources are stored in such a tree structure, they can be organized from the general (toward the tree root) to the specific (toward the tree leaves). Queries on a specific resource will automatically search the resource's hierarchy for rules assigned to ancestor resources, allowing for simple inheritance of rules. For example, if a default rule is to be applied to each building in a city, one would simply assign the rule to the city, instead of assigning the same rule to each building. Some buildings may require exceptions to such a rule, however, and this can be achieved in Zend\\Permissions\\Acl\\Acl by assigning such exception rules to each building that requires such an exception. A resource may inherit from only one parent resource, though this parent resource can have its own parent resource, etc. Zend\\Permissions\\Acl\\Acl also supports privileges on resources (e.g., \"create\", \"read\", \"update\", \"delete\"), so the developer can assign rules that affect all privileges or specific privileges on one or more resources.","title":"Resources"},{"location":"usage/#roles","text":"As with resources, creating a role is also very simple. All roles must implement Zend\\Permissions\\Acl\\Role\\RoleInterface . This interface consists of a single method, getRoleId() , Additionally, Zend\\Permissions\\Acl\\Role\\GenericRole is provided by the Zend\\Permissions\\Acl component as a basic role implementation for developers to extend as needed. In Zend\\Permissions\\Acl\\Acl , a role may inherit from one or more roles. This is to support inheritance of rules among roles. For example, a user role, such as \"sally\", may belong to one or more parent roles, such as \"editor\" and \"administrator\". The developer can assign rules to \"editor\" and \"administrator\" separately, and \"sally\" would inherit such rules from both, without having to assign rules directly to \"sally\". Though the ability to inherit from multiple roles is very useful, multiple inheritance also introduces some degree of complexity. The following example illustrates the ambiguity condition and how Zend\\Permissions\\Acl\\Acl solves it.","title":"Roles"},{"location":"usage/#creating-the-access-control-list","text":"An Access Control List (ACL) can represent any set of physical or virtual objects that you wish. For the purposes of demonstration, however, we will create a basic Content Management System (CMS) ACL that maintains several tiers of groups over a wide variety of areas. To create a new ACL object, we instantiate the ACL with no parameters: use Zend\\Permissions\\Acl\\Acl; $acl = new Acl();","title":"Creating the Access Control List"},{"location":"usage/#registering-roles","text":"CMS systems will nearly always require a hierarchy of permissions to determine the authoring capabilities of its users. There may be a 'Guest' group to allow limited access for demonstrations, a 'Staff' group for the majority of CMS users who perform most of the day-to-day operations, an 'Editor' group for those responsible for publishing, reviewing, archiving and deleting content, and finally an 'Administrator' group whose tasks may include all of those of the other groups as well as maintenance of sensitive information, user management, back-end configuration data, backup and export. This set of permissions can be represented in a role registry, allowing each group to inherit privileges from 'parent' groups, as well as providing distinct privileges for their unique group only. The permissions may be expressed as follows: Name Unique Permissions Inherit Permissions From Guest View N/A Staff Edit, Submit, Revise Guest Editor Publish, Archive, Delete Staff Administrator (Granted all access) N/A For this example, Zend\\Permissions\\Acl\\Role\\GenericRole is used, but any object that implements Zend\\Permissions\\Acl\\Role\\RoleInterface is acceptable. These groups can be added to the role registry as follows: use Zend\\Permissions\\Acl\\Acl; use Zend\\Permissions\\Acl\\Role\\GenericRole as Role; $acl = new Acl(); // Add groups to the Role registry using Zend\\Permissions\\Acl\\Role\\GenericRole // Guest does not inherit access controls $roleGuest = new Role('guest'); $acl->addRole($roleGuest); // Staff inherits from guest $acl->addRole(new Role('staff'), $roleGuest); /* Alternatively, the above could be written: $acl->addRole(new Role('staff'), 'guest'); */ // Editor inherits from staff $acl->addRole(new Role('editor'), 'staff'); // Administrator does not inherit access controls $acl->addRole(new Role('administrator'));","title":"Registering Roles"},{"location":"usage/#defining-access-controls","text":"Now that the ACL contains the relevant roles, rules can be established that define how resources may be accessed by roles. You may have noticed that we have not defined any particular resources for this example, which is simplified to illustrate that the rules apply to all resources. Zend\\Permissions\\Acl\\Acl provides an implementation whereby rules need only be assigned from general to specific, minimizing the number of rules needed, because resources and roles inherit rules that are defined upon their ancestors.","title":"Defining Access Controls"},{"location":"usage/#querying-an-acl","text":"We now have a flexible ACL that can be used to determine whether requesters have permission to perform functions throughout the web application. Performing queries is quite simple using the isAllowed() method: echo $acl->isAllowed('guest', null, 'view') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('staff', null, 'publish') ? 'allowed' : 'denied'; // denied echo $acl->isAllowed('staff', null, 'revise') ? 'allowed' : 'denied'; // allowed echo $acl->isAllowed('editor', null, 'view') ? 'allowed' : 'denied'; // allowed because of inheritance from guest echo $acl->isAllowed('editor', null, 'update') ? 'allowed' : 'denied'; // denied because no allow rule for 'update' echo $acl->isAllowed('administrator', null, 'view') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges echo $acl->isAllowed('administrator') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges echo $acl->isAllowed('administrator', null, 'update') ? 'allowed' : 'denied'; // allowed because administrator is allowed all privileges","title":"Querying an ACL"}]}